<!DOCTYPE html>
<html>
  
  <head>
    <meta name="viewport" content="width=device-width, user-scalable=no">
    <title>Javascript / Angular Styleguide</title>
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/3.0.1/normalize.min.css" />
    <link href="https://fonts.googleapis.com/css?family=Lato" rel="stylesheet" type="text/css">
    <link rel="stylesheet" type="text/css" href="css/styleguide.css" />
  </head>
  
  <body>
    
    <div id="wrapper">

      <h1>Angular Tips for JCPenney.com</h1>

      <!-- ///////////////////////////////////////////////////////////////////////////// -->

      <section>

        <h2>Overview of Angular Components</h2>

        <section>

          <h3>Models</h3>

          <p>
            Unlike most of the components we'll cover, Angular has few opinions on how to manage your models. Whereas frameworks like <a href="http://backbonejs.org/#Model" target="_blank">Backbone</a> or <a href="http://backbonejs.org/#Model" target="_blank">Ember.js</a> have special objects to model data, Angular requires nothing more than a plain old javascript object. Considering the size and complexity of the JCPenney website, we would be missing out on a great opportunity to DRY our code if we didn't fatten up those objects with some extra functionality.
          </p>

          <p>
            Take a look at the example <a href="https://github.com/jcpenney/jcp-responsive-v2/blob/master/src/coffee/models/product.coffee" target="_blank">Product</a> model below, which inherits from a bare-bones <a href="https://github.com/jcpenney/jcp-responsive-v2/blob/master/src/coffee/models/base.coffee" target="_blank">ModelBase</a>.
          </p>

          <script src="https://gist.github.com/jcpinnovation/2cc6b5d786a30f80f12d.js"></script>

          <p>
            While its business logic is certainly oversimplified, hopefully the potential value of a more formally typed and augmented object (as opposed to a data-only object) is becoming apparent. Below is a second example, a very simple <a href="https://github.com/jcpenney/jcp-responsive-v2/blob/master/src/coffee/models/review.coffee" target="_blank">Review</a> model, which could be useful for parts of the site that call for an average rating.
          </p>

          <script src="https://gist.github.com/jcpinnovation/96e554b1c2cd70d32de7.js"></script>

          <p>
            It's worth noting that each of the above-mentioned model classes is the return value for its own Angular Service. This allows us to inject the model as a dependency like we would any other Angular module, and because <a href="https://docs.angularjs.org/guide/services" target="_blank">services are singletons</a>, we don't have to worry about the class being defined more than once. We can even build subclasses, as can be seen in both of the above examples (inheriting from <a href="https://github.com/jcpenney/jcp-responsive-v2/blob/master/src/coffee/models/base.coffee" target="_blank">ModelBase</a>) or in <a href="https://github.com/jcpenney/jcp-responsive-v2/blob/master/src/coffee/models/department.coffee" target="_blank">this Department model</a>, which is a subclass of <a href="https://github.com/jcpenney/jcp-responsive-v2/blob/master/src/coffee/models/category.coffee" target="_blank">Category</a>, which is a subclass of <a href="https://github.com/jcpenney/jcp-responsive-v2/blob/master/src/coffee/models/base.coffee" target="_blank">ModelBase</a>. Once the dependency has been injected, instantiating a new instance is just a matter of typing <code>new Product(data)</code>. But where does this <code>data</code> come from, and where should models get instantiated, you ask? We'll talk about that in the next section.
          </p>

        </section>

        <section>

          <h3>Factories</h3>
          
          <p>
            As a rule of thumb, API calls and model instantiation should always be handled by a (lowercase-s) service. When it comes to choosing exactly which type of service to employ, we have the following options at our disposal, in order of increasing complexity: Services, Factories, and Providers. In most cases, we won't require service configuration during the <code>module.config</code> phase, <a href="http://demisx.github.io/angularjs/2014/09/14/angular-what-goes-where.html" target="_blank">so let's set Providers aside</a>. Services <i>could</i> get the job done, but Factories are probably a better option; as <i><a href="http://www.amazon.com/dp/1782161821/?tag=stackoverfl08-20" target="_blank">Mastering Web Application Development with AngularJS</a></i> eloquently puts it:
          </p>

          <blockquote>
            The factory method is the most common way of getting objects into AngularJS dependency injection system. It is very flexible and can contain sophisticated creation logic. Since factories are regular functions, we can also take advantage of a new lexical scope to simulate "private" variables. This is very useful as we can hide implementation details of a given service. 
          </blockquote>

          <p>
            Factories sound like a good fit. So, now that we've decided on our data-fetching-and-model-instantiation service of choice, let's talk about how to interact with our API. The obvious answer might be to use Angular's core <a href="https://docs.angularjs.org/api/ng/service/$http" target="_blank">$http</a> service, and this approach would be perfectly acceptable. However, considering the RESTful nature of JCPenney's API, we can take the abstraction up a level and really DRY out our code with Angular's <a href="https://docs.angularjs.org/api/ngResource/service/$resource" target="_blank">$resource</a> factory. Take a look at the very naive Department Factory below. (In case you're wondering, <a href="https://gist.github.com/jcpinnovation/ec7a670995fb68dd298b" target="_blank">here is the Config service</a> we're injecting.)
          </p>

          <script src="https://gist.github.com/jcpinnovation/73312408ba3dc793c847.js"></script>

          <p>
            With just two lines of code, we've enabled <a href="http://en.wikipedia.org/wiki/Create,_read,_update_and_delete" target="_blank">CRUD</a> functionality for our Department Factory. The JCPenney REST API currently doesn't respond to create, update, or delete requests, so let's forget about those for the time being. We can now fetch data for all departments or a single department with the following code:
          </p>

          <script src="https://gist.github.com/jcpinnovation/3495e0cc2a794205e1fb.js"></script>

          <p>
            You might be thinking, "Well, that's nice, but what if we have resources that require more than the basic CRUD operations?" It's pretty easy to address, but hold that thought for a moment. First, let's look at how we can cast the API responses as models, like the ones we discussed in the previous section.
          </p>

        </section>

        <section>
          <h3>Controllers</h3>
        </section>

        <section>
          <h3>Services</h3>
        </section>

        <section>
          <h3>Views</h3>
        </section>

        <section>
          <h3>Directives</h3>
        </section>

        <section>
          <h3>Filters</h3>
        </section>

      </section>

      <!-- ///////////////////////////////////////////////////////////////////////////// -->

      <section>

        <h2>App Structure</h2>

      </section>

      <!-- ///////////////////////////////////////////////////////////////////////////// -->

      <section>

        <h2>Task Runners</h2>

      </section>

      <!-- ///////////////////////////////////////////////////////////////////////////// -->

      <section>

        <h2>Resources</h2>

      </section>

      <!-- ///////////////////////////////////////////////////////////////////////////// -->

    </div>

  </body>
</html>