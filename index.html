<!DOCTYPE html>
<html>
  
  <head>
    <meta name="viewport" content="width=device-width, user-scalable=no">
    <title>Angular Tips for JCPenney.com</title>
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/3.0.1/normalize.min.css" />
    <link href='http://fonts.googleapis.com/css?family=Lato:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="css/styleguide.css" />
  </head>
  
  <body>
    
    <div id="wrapper">

      <h1>Angular Tips for JCPenney.com</h1>

      <!-- ///////////////////////////////////////////////////////////////////////////// -->

      <section id="overview-of-angular-components">

        <h2>Overview of Angular Components</h2>

        <section id="models">

          <h3>Models</h3>

          <p>
            Unlike most of the components we'll cover, Angular has few opinions on how to manage your models. Whereas frameworks like <a href="http://backbonejs.org/#Model" target="_blank">Backbone</a> or <a href="http://backbonejs.org/#Model" target="_blank">Ember.js</a> have special objects to model data, Angular requires nothing more than a plain old javascript object. Considering the size and complexity of the JCPenney website, we would be missing out on a great opportunity to DRY our code if we didn't fatten up those objects with some extra functionality.
          </p>

          <p>
            Take a look at the example Product model below, which inherits from a bare-bones <a href="https://gist.github.com/jcpinnovation/9d2d8cdd5283062b3179" target="_blank">ModelBase</a>.
          </p>

          <script src="https://gist.github.com/jcpinnovation/2cc6b5d786a30f80f12d.js"></script>

          <p>
            While its business logic is certainly oversimplified, hopefully the potential value of a more formally typed and augmented object (as opposed to a data-only object) is becoming apparent. Below is a second example, a very simple Review model, which could be useful for parts of the site that call for an average rating.
          </p>

          <script src="https://gist.github.com/jcpinnovation/96e554b1c2cd70d32de7.js"></script>

          <p>
            It's worth noting that each of the above-mentioned model classes is the return value for its own Angular Service. This allows us to inject the model as a dependency like we would any other Angular module, and because <a href="https://docs.angularjs.org/guide/services" target="_blank">services are singletons</a>, we don't have to worry about the class being defined more than once. We can even build subclasses, as can be seen in both of the above examples (inheriting from <a href="https://gist.github.com/jcpinnovation/9d2d8cdd5283062b3179" target="_blank">ModelBase</a>) or in <a href="https://gist.github.com/jcpinnovation/6e767df12bd066d9fae4" target="_blank">this Department model</a>, which is a subclass of <a href="https://gist.github.com/jcpinnovation/9751d57fcdece8487177" target="_blank">Category</a>, which is a subclass of <a href="https://github.com/jcpenney/jcp-responsive-v2/blob/master/src/coffee/models/base.coffee" target="_blank">ModelBase</a>. Once the dependency has been injected, instantiating a new instance is just a matter of typing <code>new Product(data)</code>. But where does this <code>data</code> come from, and where should models get instantiated, you ask? We'll talk about that in the next section.
          </p>

        </section>

        <section id="factories">

          <h3>Factories</h3>
          
          <p>
            As a rule of thumb, API calls and model instantiation should always be handled by a (lowercase-s) service. When it comes to choosing exactly which type of service to employ, we have the following options at our disposal, in order of increasing complexity: Services, Factories, and Providers. In most cases, we won't require service configuration during the <code>module.config</code> phase, <a href="http://demisx.github.io/angularjs/2014/09/14/angular-what-goes-where.html" target="_blank">so let's set Providers aside</a>. Services <i>could</i> get the job done, but Factories are probably a better option; as <i><a href="http://www.amazon.com/dp/1782161821/?tag=stackoverfl08-20" target="_blank">Mastering Web Application Development with AngularJS</a></i> eloquently puts it:
          </p>

          <blockquote>
            <p>
              The factory method is the most common way of getting objects into AngularJS dependency injection system. It is very flexible and can contain sophisticated creation logic. Since factories are regular functions, we can also take advantage of a new lexical scope to simulate "private" variables. This is very useful as we can hide implementation details of a given service. 
            </p>
          </blockquote>

          <p>
            Factories sound like a good fit, don't they? Now that we've decided on our data-fetching-and-model-instantiation service of choice, let's talk about how to interact with our API. The obvious answer might be to use Angular's core <a href="https://docs.angularjs.org/api/ng/service/$http" target="_blank">$http</a> service, and that approach would be perfectly acceptable. However, considering the RESTful nature of JCPenney's API, we can take the abstraction up a level and really DRY out our code with Angular's <a href="https://docs.angularjs.org/api/ngResource/service/$resource" target="_blank">$resource</a> factory. Take a look at the very naive DepartmentFactory below. (In case you're wondering, <a href="https://gist.github.com/jcpinnovation/ec7a670995fb68dd298b" target="_blank">here is the Config service</a> we're injecting.)
          </p>

          <script src="https://gist.github.com/jcpinnovation/73312408ba3dc793c847.js"></script>

          <p>
            By taking advantage of <a href="https://docs.angularjs.org/api/ngResource/service/$resource" target="_blank">$resource</a>, we now have the ability to fetch data for all departments or a single department with the following code:
          </p>

          <script src="https://gist.github.com/jcpinnovation/3495e0cc2a794205e1fb.js"></script>

          <p>
            You might be thinking, "Well, that's nice, but what about creating, updating, and destroying resources? And what if we need more than the basic CRUD operations?" Hold that thought for a moment. First, let's talk about how we can cast our API responses as models, like the ones we discussed in the previous section.
          </p>

          <p>
            The key to transforming our API response data into more useful models is <a href="https://docs.angularjs.org/api/ng/service/$http" target="_blank">$http</a>'s <code>transformResponse</code> hook, which is conveniently exposed by <a href="https://docs.angularjs.org/api/ngResource/service/$resource" target="_blank">$resource</a>. With a relatively small amount of setup code, we can create a <a href="https://github.com/jcpenney/jcp-responsive-v2/blob/master/src/coffee/factories/base.coffee">FactoryBase</a> service, providing convenience methods to generate JSON-to-model transforms for our API responses. We'll also configure basic actions for creating, updating, and destroying our custom models on the server.
          </p>

          <script src="https://gist.github.com/jcpinnovation/407c02bceb6c18c027cf.js"></script>

          <p>
            Next, we'll have DepartmentFactory extend our newly created FactoryBase, then call <code>generateResourceForModel</code> to build its default actions:
          </p>

          <script src="https://gist.github.com/jcpinnovation/b55becd4fe2b5808b53f.js"></script>

          <p>
            Now DepartmentFactory's <code>GET</code> requests will return Department models (rather than vanilla javascript objects), and we can pass our custom models as arguments to create, update, and destroy remote resources. The JCPenney API doesn't currently support mutative actions for Departments, but for the sake of this example, let's pretend it does. The code below shows how we would execute all five CRUD operations with DepartmentFactory.
          </p>

          <script src="https://gist.github.com/jcpinnovation/e47865929d53089b6db0.js"></script>

          <p>
            Neat, huh? We've got the hardest part out of the way, so let's address the second part of your question, about accessing resource endpoints beyond the basic CRUD operations. Consider the <code>GET product/:id/reviews</code> endpoint, which returns reviews associated with a given product. After implementing the boilerplate factory code (to inherit from <a href="https://gist.github.com/jcpinnovation/407c02bceb6c18c027cf" target="_blank">FactoryBase</a> and override <code>transformResponse</code> for both <code>GET</code> methods), we only need to add five lines of Coffeescript to provide support for our product reviews endpoint.
          </p>

          <script src="https://gist.github.com/jcpinnovation/9c51438958c471dfe33d.js"></script>

          <p>
            Notice that we're passing the <a href="https://gist.github.com/jcpinnovation/96e554b1c2cd70d32de7" target="_blank">Review</a> model to <code>generateArrayTransformFunctionForModel</code>, as well as specifying the optional <code>arrayPath</code> argument. The latter tells our helper method to look to the <code>reviews</code> property for its data. If this doesn't make sense right away, take a look at <a href="http://api.jcpenney.com/v2/products/pp5002690485/reviews" target="_blank">a sample product review response</a>. The <code>isArray</code> option is required by <a href="https://docs.angularjs.org/api/ngResource/service/$resource" target="_blank">$resource</a> and simply tells the service we'll be returning data in the form of an array, not an object. The code below demonstrates how we actually go about calling our new action, which will return an array of Review models.
          </p>

          <script src="https://gist.github.com/jcpinnovation/1c95ed19a8370c59c79f.js"></script>

          <p id="beauty-of-resources">
            And lastly, before moving onto the next section, let's take a moment to acknowledge one of the <a href="https://docs.angularjs.org/api/ngResource/service/$resource" target="_blank">$resource</a> module's most beautiful features. From Angular's documentation: 
          </p>

          <blockquote>
            <p>
              It is important to realize that invoking a $resource object method immediately returns an empty reference (object or array depending on isArray). Once the data is returned from the server the existing reference is populated with the actual data. This is a useful trick since usually the resource is assigned to a model which is then rendered by the view. Having an empty object results in no rendering, once the data arrives from the server then the object is populated with the data and the view automatically re-renders itself showing the new data. This means that in most cases one never has to write a callback function for the action methods.
            </p>
          </blockquote>

          <p>
            Because our factory methods immediately return an empty object/array, then populate that object/array and automatically re-render any relevant views when the data arrives, oftentimes we'll have no need for a callback. As we'll see in the next section, this is very beneficial when it comes to keeping our controllers lean.
          </p>

        </section>

        <section id="controllers">

          <h3>Controllers</h3>

          <p>
            To borrow from Todd Motto's <a href="http://toddmotto.com/rethinking-angular-js-controllers" target="_blank">"Rethinking AngularJS Controllers"</a>, the primary role of an AngularJS controller is to bring logic together; it should trigger model and view changes, but avoid getting involved in the details of their operations. The responsibility of updating models should be left to factories or the models themselves. Likewise, any changes to the UI should be addressed by directives or the views themselves.
          </p>

          <p>
            <b>
              If we're doing everything right, our controllers will contain very little code.
            </b>
          </p>

          <p>
            Let's quickly add support for querying product recommendations to our ProductFactory, then we'll look at how ProductController can give its view access to the Product, Recommendation, and Review models it needs. (In case you're wondering, <code>$stateParams</code> is a service provided by <a href="https://github.com/angular-ui/ui-router" target="_blank">Angular's ui-router</a>. In this example, we're using it to access the <code>productId</code> parameter in the URL.)
          </p>

          <script src="https://gist.github.com/jcpinnovation/eb9cdd80eab15a053aa3.js"></script>
          
          <script src="https://gist.github.com/jcpinnovation/d45b5fa770340da9c29a.js"></script>

          <p>
            If you remember <a href="#beauty-of-resources">from the Factories section</a>, $resource actions immediately return an empty reference, then populate the object/array with data when the response arrives. This means that we don't have to setup any callbacks in our controller. The above code is all we need to give our view access to its models. 
          </p>

          <p>
            Now, for our ProductController view, let's pretend we're using the markup below. This contrived example includes:
            <ol>
              <li>basic product information (name, description, image)</li>
              <li>a naive form for selecting product options, specifying quantity, and adding to bag</li>
              <li>reviews for the given product</li>
              <li>recommendations for the given product</li>
            </ol>

            <span id="directives-foreshadowing">
              Don't worry if the lack of modularity grosses you out; we'll get to that in the Directives section. <img class="emoji" alt=":)" src="img/wink.png">
            </span>

          </p>

          <script src="https://gist.github.com/jcpinnovation/225faad4faed76493d6c.js"></script>

          <p>
            With its built-in directives, Angular can take care of our form's data-binding and even help out with validation, but we'll still need to handle the add-to-bag functionality ourselves. Notice the opening tag of our view's <code>form</code> element. It specifies a name <code>productForm</code> and submit action <code>ng-submit="addToBag(product)"</code>. Let's add a method to our scope, so we can respond to the <code>addToBag</code> call. The handler should verify that the form data is valid, then facilitate the hand-off of our product to the shopping bag. For the sake of simplicity, assume that <code>BagFactory.getInstance()</code> returns a singleton Bag model that exposes an <code>add</code> method for adding products.
          </p>

          <script src="https://gist.github.com/jcpinnovation/b30e395549b67227e6fb.js"></script>

          <p>
            Well, that wasn't so bad. And our ProductController is still pretty thin at eight lines of code. For an unsophisticated view, implementing an <code>addToBag</code> handler like this would be perfectly acceptable. But in reality, JCPenney's product detail page is going to involve much more functionality that's tied to UI events (think liking/saving products, writing reviews, forms for monogramming, accordion menus, etc). While we <i>could</i> just throw this all under one controller, there's a better way, which will help keep our code organized and reusable. In the next section, we'll talk about directives.
          </p>

        </section>

        <section id="directives">

          <h3>Directives</h3>
          
          <p>
            We've alluded to directives a few times up to this point. You might be wondering, "What exactly <i>are</i> these mysterious entities?" The <a href="https://docs.angularjs.org/guide/directive" target="_blank">official AngularJS documentation</a> is a bit technical, but hopefully it begins to paint the picture:
          </p>

          <blockquote>
            <p>
              At a high level, directives are markers on a DOM element (such as an attribute, element name, comment or CSS class) that tell AngularJS's HTML compiler ($compile) to attach a specified behavior to that DOM element or even transform the DOM element and its children.
            </p>
          </blockquote>

          <p>
            One very important feature that the above definition fails to acknolwedge is that directives can manage their own scopes, as well as inherit those of their parent controllers. This means directives can function as "mini-controllers" or "nested controllers", enabling us to better encapsulate and re-use components. The following excerpt from <a href="https://leanpub.com/web-component-development-with-angularjs/read" target="_blank">Web Component Architecture &amp; Development with AngularJS</a> elaborates on this concept:
          </p>

          <blockquote>
            <p>
              One of the most useful and powerful features of AngularJS is directives. AngularJS directives are a framework convention for creating custom extensions to HTML that can encapsulate both the view and behavior of a UI component such as a site search bar in a way that can limit external dependencies, as well as providing for very flexible configuration parameters that any application or container level code may wish to provide.
            </p>
            <p>
              The AngularJS team state that using AngularJS is a way to overcome the primary shortcoming of HTML, mainly that it was designed for static presentation not dynamic, data driven interaction and presentation - a key feature of today's web. Because HTML has not evolved to provide dynamic presentation, JavaScript frameworks have risen to fill the gap, the most popular being jQuery.
            </p>
            <p>
              jQuery gives us common boilerplate code for querying the DOM, binding and listening for user or browser events, and then imperatively updating or "re-painting" the DOM in response. This was great when web applications were simple. But web applications have grown very complex, and the boilerplate code can add up to thousands of lines of source mixed in with the actual application logic.
            </p>
            <p>
              AngularJS removes the boilerplate, thus allowing JavaScript developers to opportunity to concentrate solely on the business logic of the application, and in a way that hard dependencies to the DOM are removed.
            </p>
          </blockquote>

          <p>
            Now that we have a better idea of what directives are, let's try out a simple example. Consider JCPenney's product rating stars, which appear throughout the site in search results, product detail views, and recommendations. With directives, we can "componentize" this logic so it can be shared by all the aforementioned views.
          </p>

          <script src="https://gist.github.com/jcpinnovation/8313c290d64544f48508.js"></script>

          <script src="https://gist.github.com/jcpinnovation/063c311fcc79ffa81717.js"></script>

          <script src="https://gist.github.com/jcpinnovation/076afd725a23f1b35020.js"></script>

          <p>
            So, what's happening here? The first Gist is just a template that works like any other Angular view. The view expects its scope to have an <code>isolatedProduct</code> (bear with the name for a moment). If the product has no reviews, the view renders nothing. Otherwise, it applies a "full" class to the appropriate number of star elements, then displays the number of reviews in parentheses.
          </p>

          <p>
            The second Gist shows how we define our directive. Like many of its core modules, Angular expects our directive function to return an object. Let's look at some of its available properties to see what's happening:

            <ul>
              <li>
                <b>restrict</b>: This property tells Angular how an element can communicate that it wants to use our directive. Possible values are:
                <ul>
                  <li>'A' for attribute: <code>&lt;div product-rating&gt;&lt;/div&gt;</code></li>
                  <li>'C' for class: <code>&lt;div class="product-rating"&gt;&lt;/div&gt;</code></li>
                  <li>'E' for element: <code>&lt;product-rating&gt;&lt;/product-rating&gt;</code></li>
                  <li>'M' for comment: <code>&lt;!-- product-rating --&gt;</code></li>
                  <li> we can also use any combination of the aforementioned characters, e.g. 'AE'</li>
                </ul>
                It should be noted that Angular automatically maps elements' names/classes/attributes from "HTML/CSS-case" (i.e. all lowercase, separated by dashes) to camel-case.
              </li>
              <li>
                <b>scope</b>: This property tells Angular how to manage our directive's scope. Possible values are:
                <ul>
                  <li><code>false</code>: no scope</li>
                  <li><code>true</code>: a child of the parent controller's scope</li>
                  <li><code>{}</code>: an isolated scope</li>
                </ul>
                In the case of the latter (which we're opting for in this example), we'll need to specify key-value pairs to configure how our directive can bind to data provided by the element. The keys determine the property name on our isolated scope, while the corresponding values tell Angular what attributes to look for on the element. Typically, we would use "product" as the name for all of these variables, but right now we're opting for more verbose names to better illustrate how binding works. <a href="http://stackoverflow.com/questions/14914213/when-writing-a-directive-how-do-i-decide-if-a-need-no-new-scope-a-new-child-sc" target="_blank">This StackOverflow post</a> and <a href="https://gist.github.com/CMCDragonkai/6282750" taret="_blank">this Gist of example use cases</a> are great resources for learning more about the nuances of directive scopes.
              </li>
              <li>
                <b>replace</b>: This property tells Angular whether we want to:
                <ul>
                  <li>replace the original element with our template HTML (<code>true</code>)</li>
                  <li>or embed our template's HTML within the original element (<code>false</code>)</li>
                </ul>
              </li>
              <li>
                <b>templateUrl</b>: This property tells Angular where to find the template for our element (if applicable).
              </li>
            </ul>

          </p>

          <p>
            Last but not least is our third Gist, which shows how easily we can employ our product ratings directive anywhere in the site. Had we gone with a more natural naming scheme for our scope variables (i.e. <code>scope: { product: '=product' }</code>), the usage would instead be:
          </p>

          <script src="https://gist.github.com/jcpinnovation/922d5f05040e7299187a.js"></script>

          <p>
            And the rendered HTML might look something like this:
          </p>

          <script src="https://gist.github.com/jcpinnovation/679cc23746d02372380f.js"></script>

          <p>
            And there we have it - our first Angular directive! With six lines of Coffeescript, we've gained the ability to re-use our product rating stars anywhere in the site. And every instance will rely on the same HTML partial, so we can leverage caching to cut down on our bandwidth consumption (unlike less DRY approaches, which might nest product rating HTML into every view that requires it). 
          </p>

          <p>
            If you've used frameworks like Ruby on Rails in the past, our example probably feels familiar; it's very much like a view passing local variables to a partial. In Rails, the partial is free to use helpers or call instance methods on models, but unless you're injecting logic into places where it doesn't belong, that's the extent of the partial's functionality. For server-side rendering, this is great. But on the client-side, views are much more dynamic in nature. A front-end partial/directive can't spit out some markup, brush its hands off, and say, "I'm done!" It needs to hang on to its scope and possibly react to updated data or user input. Fortunately, Angular gives us some convenient tools for handling these scenarios.
          </p>

          <p>
            Remember <a href="#directives-foreshadowing">back in the Controllers section</a>, when we alluded to the fact that directives would one day help to make our product detail page a little more modular? Well, the day has come. In our next example, we're going to extract the product form functionality to its own directive. As you'll see in the code below, the template markup looks exactly the same as before, except that it now living in its own file. You'll also recognize the <code>addToBag</code> handler, which was formerly defined in our ProductController. And to make things more interesting, we're going to introduce new logic to disable out-of-stock option values based on the user's selection. To accomplish this, we'll bind to <code>availability</code>, which we can assume to be a <a href="http://simple.wikipedia.org/wiki/Cartesian_product" target="_blank">Cartesian product</a> indicating the availability for every possible combination of product option values. You can check out an example product-availability response <a href="http://jcp-orchestration.herokuapp.com/products/pp5003721248/availability" target="_blank">here</a>. And now, without further ado, the productForm directive:
          </p>

          <script src="https://gist.github.com/jcpinnovation/1ffb7b9f1a9dad221dfc.js"></script>

          <script src="https://gist.github.com/jcpinnovation/7e6da31bf09c3d73dc79.js"></script>

          <script src="https://gist.github.com/jcpinnovation/b8745980268802f3fbdc.js"></script>

          <p>
            The <code>restrict</code>, <code>scope</code>, <code>replace</code>, and <code>templateUrl</code> properties should all look familiar, but in this example, we're introducing a new player: <code>controller</code>. As the name suggests, it works just like the view controllers we've seen before. The only difference is that our directive controller is given the option of inheriting its scope or creating an isolated scope (like we've done here), which can be assigned data by way of element attributes. While our top-level controllers are often responsible for interpreting URL parameters and orchestrating API calls to fetch data for their views, directive controllers are better suited for more fine-grain logic --- like managing the state of product option values and responding to UI click events --- which can be encapsulated and reused.
            </p>

          <p>
            It's worth noting that in the example above, <a href="http://stackoverflow.com/questions/22169888/angular-js-destroy-event-should-i-manually-unbind" target="_blank">Angular will automatically unbind our watchers</a> when the view gets destroyed. More specifically, Angular will unbind observers assigned through <code>$scope.$watch</code> and <code>$scope.$on</code> when <code>$scope</code> is destroyed. If we create any observers outside of this scope, we'll have to listen for Angular to fire a <code>$destroy</code> event, then unsubscribe manually.
          </p>

          <p>
            With data-centric directives, we often won't need to add our own listeners to DOM elements; Angular's built-in directives (e.g. <a href="https://docs.angularjs.org/api/ng/directive/ngChange" target="_blank">ng-change</a>, <a href="https://docs.angularjs.org/api/ng/directive/ngSubmit" taret="_blank">ng-submit</a>, <a href="https://docs.angularjs.org/api/ng/directive/ngClick" target="_blank">ng-click</a>, <a href="https://docs.angularjs.org/api/ng/directive/ngMouseover" target="_blank">ng-mouseover</a>, <a href="https://docs.angularjs.org/api/ng/directive/ngClass" target="_blank">ng-class</a> etc.) will go a long way. In fact, if you ever find yourself tempted to modify the DOM directly, you should take a moment to consider whether there's a cleaner, more Angular-minded approach to solving the problem. In some scenarios --- like when we're interested solely in UI behavior, not any underlying models --- it may be appropriate to utilize jQuery <b><u>in small doses</u></b>. Note the emphasis on moderation here. For these situations, it's best to utilize the <code>link</code> function, which <a href="http://www.sitepoint.com/practical-guide-angularjs-directives/" target="_blank">A Practical Guide to AngularJS Directives</a> describes as being "mainly used for attaching event listeners to DOM elements, watching model properties for changes, and updating the DOM." <a href="http://www.jvandemo.com/the-nitty-gritty-of-compile-and-link-functions-inside-angularjs-directives/" target="_blank">The Nitty-Gritty of Compile and Link Functions in AngularJS Directives</a> and <a href="http://www.toptal.com/angular-js/angular-js-demystifying-directives" target="_blank">AngularJS: Demystifying Directives</a> are great (and highly recommended) reads for understanding the ins and outs of Angular's compile and link process; but for now, let's just settle for the following explanation from <a href="http://amitgharat.wordpress.com/2013/06/08/the-hitchhikers-guide-to-the-directive/" target="_blank">The Hitchhiker's Guide to the Directive</a>:
          </p>

          <blockquote>
            <p>
              AngularJS, when bootstrapped, looks for all the directives built-in as well as custom ones, compiles them using $compile() method (which keeps track of all the directives associated with an element, sorts them by priority and produces their link function), and links with scope (created by ng-app, ng-controller, ng-include, etc) by registering listeners or setting up $watches resulted in 2 way data bindings between the scope and the element.
            </p>
          </blockquote>

          <p>
            In our next example, we're going to build a simple accordion directive. Unlike our previous directives, which specify "E" (element) as a <code>restrict</code> value, this time we'll use "C" (class) to trigger our directive. We'll omit the <code>scope</code> property, because our directive doesn't need to worry about data. Similarly, we can leave out <code>replace</code> and <code>templateUrl</code>, as we won't have to inject any templates. By default, our directive will expect the accordion element to contain a <code>&lt;section&gt;</code> for each of its logical groups. Each <code>&lt;section&gt;</code> should then include the following:

            <ul>
              <li>
                one immediate child with "heading" class; this element will expand/collapse its parent <code>&lt;section&gt;</code> on click.
              </li>
              <li>
                one immediate child with a "content" class, following the aforementioned "heading"; this element will contain the content that becomes visible when its parent <code>&lt;section&gt;</code> is expanded.
              </li>
            </ul>

             When a <code>&lt;section&gt;</code> is expanded, it will be assigned an "expanded" class. Without any styling, our accordion directive won't appear to do much of anything, but it provides all the meta data we need to create the desired visual behavior with SCSS. By implementing the accordion in an unobtrusive, class-oriented manner, we keep design out of our Javascript and give ourselves freedom to do what we want with the markup (so long as a few basic requirements are met). The default section selector, heading selector, and expanded class can also be overwritten via <code>section-selector</code>, <code>heading-selector</code>, and <code>expanded-class</code> attributes to the accordion element. But enough introduction, let's see how this actually works in practice.

          </p>

          <script src="https://gist.github.com/jcpinnovation/54b505ef47869f5a76a1.js"></script>

          <script src="https://gist.github.com/jcpinnovation/deff645ca6301ea46900.js"></script>

          <script src="https://gist.github.com/jcpinnovation/d0a43aef88b8be18cb1b.js"></script>

          <p>
            The JCPenney site is full of opportunities to utilize directives; product results (like you would see after drilling down to a category or searching for "winter coats"), recommendations, reviews, loading indicators, and accordions are just a few candidates that immediately come to mind. And don't forget that directives can be nested within other directives, so bite-sized components (like our product rating stars or a directive to display pricing information for a product) can be assembled into much more complex (but still self-contained) pieces of functionality.
          </p>

        </section>

        <section id="filters">

            <h3>Filters</h3>

            <p>Coming soon!</p>

        </section>

      </section>

      <!-- ///////////////////////////////////////////////////////////////////////////// -->

      <section id="app-structure">

        <h2>App Structure and Naming Conventions</h2>

        <p>
          We've talked a lot about how to use Angular components, but up until this point, we haven't given much attention to where we should put them. Our application structure, which is inspired by that of a typical Rails app, will include a directory for each type of Angular object. That is to say, controllers, factories, filters, models, and services will all have their own folders. View templates and SCSS files will also have their own directories, inside each of which we'll add <code>pages</code> and <code>components</code> subdirectories, for more granular organization that corresponds to controllers and directives. To better visualize the described pattern, take a look at the skeleton structure below.
        </p>

        <div class="file-tree">
          <ul>
            <li>
              <span class="dir open">src</span>
              <ul>
                <li>
                  <span class="dir open">coffee</span>
                  <ul>
                    <li class="dir">controllers</li>
                    <li class="dir">directives</li>
                    <li class="dir">factories</li>
                    <li class="dir">filters</li>
                    <li class="dir">models</li>
                    <li class="dir">services</li>
                    <li class="file">app.coffee</li>
                    <li class="file">config.coffee</li>
                  </ul>
                </li>
                <li>
                  <span class="dir open">img</span>
                </li>
                <li>
                  <span class="dir open">scss</span>
                  <ul>
                    <li class="dir">components</li>
                    <li class="dir">pages</li>
                    <li class="dir">theme</li>
                    <li class="file">application.scss</li>
                  </ul>
                </li>
                <li>
                  <span class="dir open">views</span>
                  <ul>
                    <li class="dir">components</li>
                    <li class="dir">pages</li>
                  </ul>
                </li>
                <li class="file">index.html</li>
              </ul>
            </li>
          </ul>
        </div>

        <p>
          Now that we have a better sense of the hierarchy, let's revisit the tree, only this time with more files added. Note that we're using <a href="http://en.wikipedia.org/wiki/Snake_case" target="_blank">snake case</a> for all of our filenames. As a rule of thumb, a file's name should reflect that of the one (and only) component it defines. For example, our ProductController lives in <code>product_controller.coffee</code>, our Department model lives in <code>department.coffee</code>, and our productForm directive lives in <code>product_form.coffee</code>. View template names should correspond to their respective controllers or directives; controller views go in <code>views/pages</code>, while directive views go in <code>views/components</code>. Similarly, SCSS file organization should reflect that of our views.
        </p>

        <div class="file-tree">
          <ul>
            <li>
              <span class="dir open">src</span>
              <ul>
                <li>
                  <span class="dir open">coffee</span>
                  <ul>
                    <li>
                      <span class="dir open">controllers</span>
                      <ul>
                        <li class="file">account_controller.coffee</li>
                        <li class="file">category_controller.coffee</li>
                        <li class="file">checkout_controller.coffee</li>
                        <li class="file">departments_controller.coffee</li>
                        <li class="file">home_controller.coffee</li>
                        <li class="file">product_controller.coffee</li>
                        <li class="file">registry_controller.coffee</li>
                        <li class="file">search_controller.coffee</li>
                        <li class="file">store_locator_controller.coffee</li>
                      </ul>
                    </li>
                    <li>
                      <span class="dir open">directives</span>
                      <ul>
                        <li class="file">accordion.coffee</li>
                        <li class="file">bag.coffee</li>
                        <li class="file">footer.coffee</li>
                        <li class="file">header.coffee</li>
                        <li class="file">loader.coffee</li>
                        <li class="file">modal.coffee</li>
                        <li class="file">product_form.coffee</li>
                        <li class="file">product_rating.coffee</li>
                        <li class="file">product_result.coffee</li>
                        <li class="file">recommendation.coffee</li>
                        <li class="file">review.coffee</li>
                      </ul>
                    </li>
                    <li>
                      <span class="dir open">factories</span>
                      <ul>
                        <li class="file">category_factory.coffee</li>
                        <li class="file">customer_factory.coffee</li>
                        <li class="file">department_factory.coffee</li>
                        <li class="file">product_factory.coffee</li>
                        <li class="file">store_factory.coffee</li>
                      </ul>
                    </li>
                    <li>
                      <span class="dir open">filters</span>
                      <ul>
                        <li class="file">product_price.coffee</li>
                        <li class="file">vdata_option_value_name.coffee</li>
                      </ul>
                    </li>
                    <li>
                      <span class="dir open">models</span>
                      <ul>
                        <li class="file">category.coffee</li>
                        <li class="file">customer.coffee</li>
                        <li class="file">department.coffee</li>
                        <li class="file">product.coffee</li>
                        <li class="file">recommendation.coffee</li>
                        <li class="file">review.coffee</li>
                        <li class="file">store.coffee</li>
                      </ul>
                    </li>
                    <li>
                      <span class="dir open">services</span>
                      <ul>
                        <li class="file">interceptor.coffee</li>
                        <li class="file">shared_data.coffee</li>
                      </ul>
                    </li>
                    <li class="file">app.coffee</li>
                    <li class="file">config.coffee</li>
                  </ul>
                </li>
                <li>
                  <span class="dir open">img</span>
                </li>
                <li>
                  <span class="dir open">scss</span>
                  <ul>
                    <li>
                      <span class="dir open">components</span>
                      <ul>
                        <li class="file">_accordion.scss</li>
                        <li class="file">_bag.scss</li>
                        <li class="file">_footer.scss</li>
                        <li class="file">_header.scss</li>
                        <li class="file">_loader.scss</li>
                        <li class="file">_modal.scss</li>
                        <li class="file">_product_form.scss</li>
                        <li class="file">_product_rating.scss</li>
                        <li class="file">_product_result.scss</li>
                        <li class="file">_recommendation.scss</li>
                        <li class="file">_review.scss</li>
                      </ul>
                    </li>
                    <li>
                      <span class="dir open">pages</span>
                      <ul>
                        <li class="file">_account.scss</li>
                        <li class="file">_category.scss</li>
                        <li class="file">_checkout.scss</li>
                        <li class="file">_departments.scss</li>
                        <li class="file">_home.scss</li>
                        <li class="file">_product.scss</li>
                        <li class="file">_registry.scss</li>
                        <li class="file">_search.scss</li>
                        <li class="file">_store_locator.scss</li>
                      </ul>
                    </li>
                    <li>
                      <span class="dir open">theme</span>
                      <ul>
                        <li class="file">_buttons.scss</li>
                        <li class="file">_fonts.scss</li>
                        <li class="file">_headings.scss</li>
                        <li class="file">_inputs.scss</li>
                        <li class="file">_layouts.scss</li>
                        <li class="file">_links.scss</li>
                        <li class="file">_lists.scss</li>
                      </ul>
                    </li>
                    <li class="file">_config.scss</li>
                    <li class="file">_mixins.scss</li>
                    <li class="file">application.scss</li>
                  </ul>
                </li>
                <li>
                  <span class="dir open">views</span>
                  <ul>
                    <li>
                      <span class="dir open">components</span>
                      <ul>
                        <li class="file">accordion.html</li>
                        <li class="file">bag.html</li>
                        <li class="file">footer.html</li>
                        <li class="file">header.html</li>
                        <li class="file">loader.html</li>
                        <li class="file">modal.html</li>
                        <li class="file">product_form.html</li>
                        <li class="file">product_rating.html</li>
                        <li class="file">product_result.html</li>
                        <li class="file">recommendation.html</li>
                        <li class="file">review.html</li>
                      </ul>
                    </li>
                    <li>
                      <span class="dir open">pages</span>
                      <ul>
                        <li class="file">account.html</li>
                        <li class="file">category.html</li>
                        <li class="file">checkout.html</li>
                        <li class="file">departments.html</li>
                        <li class="file">home.html</li>
                        <li class="file">product.html</li>
                        <li class="file">registry.html</li>
                        <li class="file">search.html</li>
                        <li class="file">store_locator.html</li>
                      </ul>
                    </li>
                  </ul>
                </li>
                <li class="file">index.html</li>
              </ul>
            </li>
          </ul>
        </div>

        <p>
          Now that we're getting a sense of how we should organize our app, let's briefly talk about why. There are a few important benefits to this application structure:
        </p>

        <h4>Relevant files are easy to find.</h4>
        <p>
          The pages of our app can be easily identified by browsing the <code>coffee/controllers</code> directory. Let's pretend we're interested in the search page (i.e. SearchController); we immediately know that the corresponding template lives in <code>views/pages</code> and has the name <code>search.html</code>. Assuming we're taking advantage of directives, our template should be relatively minimal. Inside, we'll probably find an <code>ng-repeat</code> iterating over a <code>&lt;product-result&gt;&lt;product-result/&gt;</code>. The <code>product-result</code> element should immediately jump out as being a non-native HTML element, tipping us off that it's most likely a directive. We then know that the directive definition should live in the <code>coffee/directives</code> directory under the filename <code>product-result.coffee</code>, and its corresponding view and styling can be found in <code>views/components/product_result.html</code> and <code>scss/components/_product_result.scss</code>, respectively.
        </p>
        
        <h4>New developers can make sense of the code base without being intimately familiar with JCPenney's site.</h4>
        <p>
          In the previous paragraph, we demonstrated how it's possible to anticipate exactly where to find component definitions, view templates, and SCSS files with very little knowledge of the application itself. With the structure we've adopted, Angular developers can feasibly orient themselves to a project in under a day's time. This may not be possible for an application whose skeleton is based around logic tied to a specific site/business.
        </p>

        <h4>Code re-use is encouraged.</h4>
        <p>
          When the time comes to build out a new feature, our structure makes it comparatively easy to check whether the required functionality has already been implemented elsewhere. Let's pretend we're developing a new component that shows the nearby in-store availability for products on a customer's wish list. One of the prerequisites is going to be figuring out which stores are close to the current user's location; that's probably going to involve querying the API's <code>/stores</code> endpoint with a latitude and longitude. Before diving in and writing custom code to fetch this data, we can do a quick scan of the <code>coffee/factories</code> directory (where most/all of our API calls are made) to verify that another developer hasn't coded something similar. In doing so, we would learn that StoreFactory already provides the exact functionality we're looking for. (It was originally implemented for the Store Locator page of the site.) Had our application's skeleton been structured around components, we might not have any idea where to look for pre-existing logic. We may have gotten lucky and noticed that "store" was in the component's name, but then where would we move the factory logic in order to share it across multiple components?
        </p>

        <h4>Consistent code style is encouraged.</h4>
        <p>
          Another virtue of our each-type-has-its-own-directory structure is that code lives next to code that behaves similarly. This makes it easy to refer to and mimic the conventions of sibling components. For example, if we were implementing the <a href="https://gist.github.com/jcpinnovation/b55becd4fe2b5808b53f" target="_blank">DepartmentFactory</a>, we could inspect the already-existing <a href="https://gist.github.com/jcpinnovation/eb9cdd80eab15a053aa3" target="_blank">ProductFactory</a> and may learn that we should probably be extending <a href="https://gist.github.com/jcpinnovation/407c02bceb6c18c027cf" target="_blank">FactoryBase</a> and making use of its <code>generateResourceForModel</code> method, if we didn't already know that.
        </p>

        <h4>Files can be grouped into sub-directories if necessary.</h4>

        <p>
          Our code base will inevitably grow, and at some point, our folders might become too populated for our liking. Fortunately, this application structure doesn't prevent us from tidying things up with nested folders. For example, if <code>coffee/directives</code> becomes unwieldy, we could start grouping our directives into logical sub-directories. Perhaps <code>product_form.coffee</code>, <code>product_rating.coffee</code>, and <code>product_result.coffee</code> could move to a <code>products</code> sub-directory, while <code>bag.html</code>, <code>footer.html</code>, and <code>header.html</code> go into a <code>layout</code> sub-directory, and <code>accordion.html</code> and <code>modal.html</code> move to a <code>UI</code> sub-directory. To ensure consistency, the corresponding view templates and SCSS files would be grouped into sub-directories to match their directives.
        </p>

      </section>

      <!-- ///////////////////////////////////////////////////////////////////////////// -->

      <section id="task-runners">

        <h2>Task Runners</h2>
        <p>Coming soon!</p>

      </section>


      <!-- ///////////////////////////////////////////////////////////////////////////// -->

    </div>

  </body>
</html>