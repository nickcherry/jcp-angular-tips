<!DOCTYPE html>
<html>
  
  <head>
    <meta name="viewport" content="width=device-width, user-scalable=no">
    <title>Angular Tips for JCPenney.com</title>
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/3.0.1/normalize.min.css" />
    <link href="https://fonts.googleapis.com/css?family=Lato" rel="stylesheet" type="text/css">
    <link rel="stylesheet" type="text/css" href="css/styleguide.css" />
  </head>
  
  <body>
    
    <div id="wrapper">

      <h1>Angular Tips for JCPenney.com</h1>

      <!-- ///////////////////////////////////////////////////////////////////////////// -->

      <section>

        <h2>Overview of Angular Components</h2>

        <section>

          <h3>Models</h3>

          <p>
            Unlike most of the components we'll cover, Angular has few opinions on how to manage your models. Whereas frameworks like <a href="http://backbonejs.org/#Model" target="_blank">Backbone</a> or <a href="http://backbonejs.org/#Model" target="_blank">Ember.js</a> have special objects to model data, Angular requires nothing more than a plain old javascript object. Considering the size and complexity of the JCPenney website, we would be missing out on a great opportunity to DRY our code if we didn't fatten up those objects with some extra functionality.
          </p>

          <p>
            Take a look at the example <a href="https://github.com/jcpenney/jcp-responsive-v2/blob/master/src/coffee/models/product.coffee" target="_blank">Product</a> model below, which inherits from a bare-bones <a href="https://github.com/jcpenney/jcp-responsive-v2/blob/master/src/coffee/models/base.coffee" target="_blank">ModelBase</a>.
          </p>

          <script src="https://gist.github.com/jcpinnovation/2cc6b5d786a30f80f12d.js"></script>

          <p>
            While its business logic is certainly oversimplified, hopefully the potential value of a more formally typed and augmented object (as opposed to a data-only object) is becoming apparent. Below is a second example, a very simple <a href="https://github.com/jcpenney/jcp-responsive-v2/blob/master/src/coffee/models/review.coffee" target="_blank">Review</a> model, which could be useful for parts of the site that call for an average rating.
          </p>

          <script src="https://gist.github.com/jcpinnovation/96e554b1c2cd70d32de7.js"></script>

          <p>
            It's worth noting that each of the above-mentioned model classes is the return value for its own Angular Service. This allows us to inject the model as a dependency like we would any other Angular module, and because <a href="https://docs.angularjs.org/guide/services" target="_blank">services are singletons</a>, we don't have to worry about the class being defined more than once. We can even build subclasses, as can be seen in both of the above examples (inheriting from <a href="https://github.com/jcpenney/jcp-responsive-v2/blob/master/src/coffee/models/base.coffee" target="_blank">ModelBase</a>) or in <a href="https://github.com/jcpenney/jcp-responsive-v2/blob/master/src/coffee/models/department.coffee" target="_blank">this Department model</a>, which is a subclass of <a href="https://github.com/jcpenney/jcp-responsive-v2/blob/master/src/coffee/models/category.coffee" target="_blank">Category</a>, which is a subclass of <a href="https://github.com/jcpenney/jcp-responsive-v2/blob/master/src/coffee/models/base.coffee" target="_blank">ModelBase</a>. Once the dependency has been injected, instantiating a new instance is just a matter of typing <code>new Product(data)</code>. But where does this <code>data</code> come from, and where should models get instantiated, you ask? We'll talk about that in the next section.
          </p>

        </section>

        <section>

          <h3>Factories</h3>
          
          <p>
            As a rule of thumb, API calls and model instantiation should always be handled by a (lowercase-s) service. When it comes to choosing exactly which type of service to employ, we have the following options at our disposal, in order of increasing complexity: Services, Factories, and Providers. In most cases, we won't require service configuration during the <code>module.config</code> phase, <a href="http://demisx.github.io/angularjs/2014/09/14/angular-what-goes-where.html" target="_blank">so let's set Providers aside</a>. Services <i>could</i> get the job done, but Factories are probably a better option; as <i><a href="http://www.amazon.com/dp/1782161821/?tag=stackoverfl08-20" target="_blank">Mastering Web Application Development with AngularJS</a></i> eloquently puts it:
          </p>

          <blockquote>
            The factory method is the most common way of getting objects into AngularJS dependency injection system. It is very flexible and can contain sophisticated creation logic. Since factories are regular functions, we can also take advantage of a new lexical scope to simulate "private" variables. This is very useful as we can hide implementation details of a given service. 
          </blockquote>

          <p>
            Factories sound like a good fit, don't they? Now that we've decided on our data-fetching-and-model-instantiation service of choice, let's talk about how to interact with our API. The obvious answer might be to use Angular's core <a href="https://docs.angularjs.org/api/ng/service/$http" target="_blank">$http</a> service, and that approach would be perfectly acceptable. However, considering the RESTful nature of JCPenney's API, we can take the abstraction up a level and really DRY out our code with Angular's <a href="https://docs.angularjs.org/api/ngResource/service/$resource" target="_blank">$resource</a> factory. Take a look at the very naive DepartmentFactory below. (In case you're wondering, <a href="https://gist.github.com/jcpinnovation/ec7a670995fb68dd298b" target="_blank">here is the Config service</a> we're injecting.)
          </p>

          <script src="https://gist.github.com/jcpinnovation/73312408ba3dc793c847.js"></script>

          <p>
            With a single line of code, we've enabled <a href="http://en.wikipedia.org/wiki/Create,_read,_update_and_delete" target="_blank">CRUD</a> functionality for our DepartmentFactory. The JCPenney REST API currently doesn't respond to create, update, or delete requests, so let's forget about those for now. With our factory in place, we can fetch data for all departments or a single department with the following code:
          </p>

          <script src="https://gist.github.com/jcpinnovation/3495e0cc2a794205e1fb.js"></script>

          <p>
            You might be thinking, "Well, that's nice, but what if we have resources that require more than the basic CRUD operations?" It's pretty easy to address, but hold that thought for a moment. First, let's see how we can cast the API responses as models, like the ones we discussed in the previous section.
          </p>

          <p>
            The key to transforming our API response data into more useful models is <a href="https://docs.angularjs.org/api/ng/service/$http" target="_blank">$http</a>'s <code>transformResponse</code> hook, which is conveniently exposed by <a href="https://docs.angularjs.org/api/ngResource/service/$resource" target="_blank">$resource</a>. With a relatively small amount of setup code, we can create a <a href="https://github.com/jcpenney/jcp-responsive-v2/blob/master/src/coffee/factories/base.coffee">FactoryBase</a> service, providing convenience methods to generate JSON-to-model transforms for our API responses and basic actions for creating, updating, and destroying our custom models on the server.
          </p>

          <script src="https://gist.github.com/jcpinnovation/407c02bceb6c18c027cf.js"></script>

          <p>
            With DepartmentFactory inheriting from FactoryBase and calling <code>generateResourceForModel</code>, our <code>GET</code> requests will return Department models (rather than vanilla javascript objects) and we can now pass our custom models as arguments to create, update, and destroy remote resources. Again, the JCPenney API doesn't currently support mutative actions for Departments, but for the sake of this example, let's pretend it does. The code below shows how we would execute all five CRUD operations with DepartmentFactory:
          </p>

          <script src="https://gist.github.com/jcpinnovation/e47865929d53089b6db0.js"></script>

          <p>
            Neat, huh? We've got the hardest part out of the way, so let's get back to your question about accessing resource endpoints beyond the basic CRUD operations. Consider the <code>GET product/:id/reviews</code> endpoint, which returns reviews associated with a given product. After implementing the boilerplate factory code (to inherit from <a href="https://gist.github.com/jcpinnovation/407c02bceb6c18c027cf" target="_blank">FactoryBase</a> and override <code>transformResponse</code> for both <code>GET</code> methods), we only need to add four lines of Coffeescript to provide support for our product reviews endpoint.
          </p>

          <script src="https://gist.github.com/jcpinnovation/9c51438958c471dfe33d.js"></script>

          <p>
            Notice that we're passing the <a href="https://gist.github.com/jcpinnovation/96e554b1c2cd70d32de7" target="_blank">Review</a> model to <code>generateArrayTransformFunctionForModel</code>, as well as specifying the optional <code>arrayPath</code> argument. The latter tells our helper method to look to the <code>reviews</code> property for its data. If this doesn't make sense right away, take a look at <a href="http://api.jcpenney.com/v2/products/pp5002690485/reviews" target="_blank">a sample product review response</a>. The <code>isArray</code> option is required by <a href="https://docs.angularjs.org/api/ngResource/service/$resource" target="_blank">$resource</a> and simply tells the service we'll be returning data in the form of an array, not an object. The code below demonstrates how we actually go about calling our new action, which will return an array of Review models.
          </p>

          <script src="https://gist.github.com/jcpinnovation/1c95ed19a8370c59c79f.js"></script>

          <p>
            And lastly, before moving onto the next section, let's take a moment to acknowledge one of the <a href="https://docs.angularjs.org/api/ngResource/service/$resource" target="_blank">$resource</a> module's most beautiful features. From Angular's documentation: 
          </p>

          <blockquote>
            It is important to realize that invoking a $resource object method immediately returns an empty reference (object or array depending on isArray). Once the data is returned from the server the existing reference is populated with the actual data. This is a useful trick since usually the resource is assigned to a model which is then rendered by the view. Having an empty object results in no rendering, once the data arrives from the server then the object is populated with the data and the view automatically re-renders itself showing the new data. This means that in most cases one never has to write a callback function for the action methods.
          </blockquote>

          <p>
            Because our factory methods immediately return an empty object/array, then populate that object/array and automatically re-render any relevant views when the data arrives, oftentimes we'll have no need for a callback. As we'll see in the next section, this is very beneficial when it comes to keeping our controllers lean.
          </p>

        </section>

        <section>

          <h3>Controllers</h3>

          <p>
            
          </p>

        </section>

        <section>
          <h3>Services</h3>
        </section>

        <section>
          <h3>Views</h3>
        </section>

        <section>
          <h3>Directives</h3>
        </section>

        <section>
          <h3>Filters</h3>
        </section>

      </section>

      <!-- ///////////////////////////////////////////////////////////////////////////// -->

      <section>

        <h2>App Structure</h2>

      </section>

      <!-- ///////////////////////////////////////////////////////////////////////////// -->

      <section>

        <h2>Task Runners</h2>

      </section>

      <!-- ///////////////////////////////////////////////////////////////////////////// -->

      <section>

        <h2>Resources</h2>

      </section>

      <!-- ///////////////////////////////////////////////////////////////////////////// -->

    </div>

  </body>
</html>