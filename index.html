<!DOCTYPE html>
<html>
  
  <head>
    <meta name="viewport" content="width=device-width, user-scalable=no">
    <title>Angular Tips for JCPenney.com</title>
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/3.0.1/normalize.min.css" />
    <link href="https://fonts.googleapis.com/css?family=Lato" rel="stylesheet" type="text/css">
    <link rel="stylesheet" type="text/css" href="css/styleguide.css" />
  </head>
  
  <body>
    
    <div id="wrapper">

      <h1>Angular Tips for JCPenney.com</h1>

      <!-- ///////////////////////////////////////////////////////////////////////////// -->

      <section>

        <h2>Overview of Angular Components</h2>

        <section>

          <h3>Models</h3>

          <p>
            Unlike most of the components we'll cover, Angular has few opinions on how to manage your models. Whereas frameworks like <a href="http://backbonejs.org/#Model" target="_blank">Backbone</a> or <a href="http://backbonejs.org/#Model" target="_blank">Ember.js</a> have special objects to model data, Angular requires nothing more than a plain old javascript object. Considering the size and complexity of the JCPenney website, we would be missing out on a great opportunity to DRY our code if we didn't fatten up those objects with some extra functionality.
          </p>

          <p>
            Take a look at the example <a href="https://github.com/jcpenney/jcp-responsive-v2/blob/master/src/coffee/models/product.coffee" target="_blank">Product</a> model below, which inherits from a bare-bones <a href="https://github.com/jcpenney/jcp-responsive-v2/blob/master/src/coffee/models/base.coffee" target="_blank">ModelBase</a>.
          </p>

          <script src="https://gist.github.com/jcpinnovation/2cc6b5d786a30f80f12d.js"></script>

          <p>
            While its business logic is certainly oversimplified, hopefully the potential value of a more formally typed and augmented object (as opposed to a data-only object) is becoming apparent. Below is a second example, a very simple <a href="https://github.com/jcpenney/jcp-responsive-v2/blob/master/src/coffee/models/review.coffee" target="_blank">Review</a> model, which could be useful for parts of the site that call for an average rating.
          </p>

          <script src="https://gist.github.com/jcpinnovation/96e554b1c2cd70d32de7.js"></script>

          <p>
            It's worth noting that each of the above-mentioned model classes is the return value for its own Angular Service. This allows us to inject the model as a dependency like we would any other Angular module, and because <a href="https://docs.angularjs.org/guide/services" target="_blank">services are singletons</a>, we don't have to worry about the class being defined more than once. We can even build subclasses, as can be seen in both of the above examples (inheriting from <a href="https://github.com/jcpenney/jcp-responsive-v2/blob/master/src/coffee/models/base.coffee" target="_blank">ModelBase</a>) or in <a href="https://github.com/jcpenney/jcp-responsive-v2/blob/master/src/coffee/models/department.coffee" target="_blank">this Department model</a>, which is a subclass of <a href="https://github.com/jcpenney/jcp-responsive-v2/blob/master/src/coffee/models/category.coffee" target="_blank">Category</a>, which is a subclass of <a href="https://github.com/jcpenney/jcp-responsive-v2/blob/master/src/coffee/models/base.coffee" target="_blank">ModelBase</a>. Once the dependency has been injected, instantiating a new instance is just a matter of typing <code>new Product(data)</code>. But where does this <code>data</code> come from, and where should models get instantiated, you ask? We'll talk about that in the next section.
          </p>

        </section>

        <section>

          <h3>Factories</h3>
          
          <p>
            As a rule of thumb, API calls and model instantiation should always be handled by a (lowercase-s) service. When it comes to choosing exactly which type of service to employ, we have the following options at our disposal, in order of increasing complexity: Services, Factories, and Providers. In most cases, we won't require service configuration during the <code>module.config</code> phase, <a href="http://demisx.github.io/angularjs/2014/09/14/angular-what-goes-where.html" target="_blank">so let's set Providers aside</a>. Services <i>could</i> get the job done, but Factories are probably a better option; as <i><a href="http://www.amazon.com/dp/1782161821/?tag=stackoverfl08-20" target="_blank">Mastering Web Application Development with AngularJS</a></i> eloquently puts it:
          </p>

          <blockquote>
            <p>
              The factory method is the most common way of getting objects into AngularJS dependency injection system. It is very flexible and can contain sophisticated creation logic. Since factories are regular functions, we can also take advantage of a new lexical scope to simulate "private" variables. This is very useful as we can hide implementation details of a given service. 
            </p>
          </blockquote>

          <p>
            Factories sound like a good fit, don't they? Now that we've decided on our data-fetching-and-model-instantiation service of choice, let's talk about how to interact with our API. The obvious answer might be to use Angular's core <a href="https://docs.angularjs.org/api/ng/service/$http" target="_blank">$http</a> service, and that approach would be perfectly acceptable. However, considering the RESTful nature of JCPenney's API, we can take the abstraction up a level and really DRY out our code with Angular's <a href="https://docs.angularjs.org/api/ngResource/service/$resource" target="_blank">$resource</a> factory. Take a look at the very naive DepartmentFactory below. (In case you're wondering, <a href="https://gist.github.com/jcpinnovation/ec7a670995fb68dd298b" target="_blank">here is the Config service</a> we're injecting.)
          </p>

          <script src="https://gist.github.com/jcpinnovation/73312408ba3dc793c847.js"></script>

          <p>
            By taking advantage of <a href="https://docs.angularjs.org/api/ngResource/service/$resource" target="_blank">$resource</a>, we now have the ability to fetch data for all departments or a single department with the following code:
          </p>

          <script src="https://gist.github.com/jcpinnovation/3495e0cc2a794205e1fb.js"></script>

          <p>
            You might be thinking, "Well, that's nice, but what about creating, updating, and destroying resources? And what if we need more than the basic CRUD operations?" Hold that thought for a moment. First, let's talk about how we can cast our API responses as models, like the ones we discussed in the previous section.
          </p>

          <p>
            The key to transforming our API response data into more useful models is <a href="https://docs.angularjs.org/api/ng/service/$http" target="_blank">$http</a>'s <code>transformResponse</code> hook, which is conveniently exposed by <a href="https://docs.angularjs.org/api/ngResource/service/$resource" target="_blank">$resource</a>. With a relatively small amount of setup code, we can create a <a href="https://github.com/jcpenney/jcp-responsive-v2/blob/master/src/coffee/factories/base.coffee">FactoryBase</a> service, providing convenience methods to generate JSON-to-model transforms for our API responses. We'll also configure basic actions for creating, updating, and destroying our custom models on the server.
          </p>

          <script src="https://gist.github.com/jcpinnovation/407c02bceb6c18c027cf.js"></script>

          <p>
            Next, we'll have DepartmentFactory extend our newly created FactoryBase, then call <code>generateResourceForModel</code> to build its default actions:
          </p>

          <script src="https://gist.github.com/jcpinnovation/b55becd4fe2b5808b53f.js"></script>

          <p>
            Now DepartmentFactory's <code>GET</code> requests will return Department models (rather than vanilla javascript objects), and we can pass our custom models as arguments to create, update, and destroy remote resources. The JCPenney API doesn't currently support mutative actions for Departments, but for the sake of this example, let's pretend it does. The code below shows how we would execute all five CRUD operations with DepartmentFactory.
          </p>

          <script src="https://gist.github.com/jcpinnovation/e47865929d53089b6db0.js"></script>

          <p>
            Neat, huh? We've got the hardest part out of the way, so let's address the second part of your question, about accessing resource endpoints beyond the basic CRUD operations. Consider the <code>GET product/:id/reviews</code> endpoint, which returns reviews associated with a given product. After implementing the boilerplate factory code (to inherit from <a href="https://gist.github.com/jcpinnovation/407c02bceb6c18c027cf" target="_blank">FactoryBase</a> and override <code>transformResponse</code> for both <code>GET</code> methods), we only need to add five lines of Coffeescript to provide support for our product reviews endpoint.
          </p>

          <script src="https://gist.github.com/jcpinnovation/9c51438958c471dfe33d.js"></script>

          <p>
            Notice that we're passing the <a href="https://gist.github.com/jcpinnovation/96e554b1c2cd70d32de7" target="_blank">Review</a> model to <code>generateArrayTransformFunctionForModel</code>, as well as specifying the optional <code>arrayPath</code> argument. The latter tells our helper method to look to the <code>reviews</code> property for its data. If this doesn't make sense right away, take a look at <a href="http://api.jcpenney.com/v2/products/pp5002690485/reviews" target="_blank">a sample product review response</a>. The <code>isArray</code> option is required by <a href="https://docs.angularjs.org/api/ngResource/service/$resource" target="_blank">$resource</a> and simply tells the service we'll be returning data in the form of an array, not an object. The code below demonstrates how we actually go about calling our new action, which will return an array of Review models.
          </p>

          <script src="https://gist.github.com/jcpinnovation/1c95ed19a8370c59c79f.js"></script>

          <p>
            And lastly, before moving onto the next section, let's take a moment to acknowledge one of the <a href="https://docs.angularjs.org/api/ngResource/service/$resource" target="_blank">$resource</a> module's most beautiful features. From Angular's documentation: 
          </p>

          <blockquote>
            <p>
              It is important to realize that invoking a $resource object method immediately returns an empty reference (object or array depending on isArray). Once the data is returned from the server the existing reference is populated with the actual data. This is a useful trick since usually the resource is assigned to a model which is then rendered by the view. Having an empty object results in no rendering, once the data arrives from the server then the object is populated with the data and the view automatically re-renders itself showing the new data. This means that in most cases one never has to write a callback function for the action methods.
            </p>
          </blockquote>

          <p>
            Because our factory methods immediately return an empty object/array, then populate that object/array and automatically re-render any relevant views when the data arrives, oftentimes we'll have no need for a callback. As we'll see in the next section, this is very beneficial when it comes to keeping our controllers lean.
          </p>

        </section>

        <section>

          <h3>Controllers</h3>

          <p>
            To borrow from Todd Motto's <a href="http://toddmotto.com/rethinking-angular-js-controllers" target="_blank">"Rethinking AngularJS Controllers"</a>, the primary role of an AngularJS controller is to bring logic together; it should trigger model and view changes, but avoid getting involved in the details of their operations. The responsibility of updating models should be left to factories or the models themselves. Likewise, any changes to the UI should be addressed by directives or the views themselves.
          </p>

          <p>
            <b>
              If we're doing everything right, our controllers will contain very little code.
            </b>
          </p>

          <p>
            Let's quickly add support for querying product recommendations to our ProductFactory, then we'll look at how ProductController can give its view access to the Product, Recommendation, and Review models it needs. (In case you're wondering, <code>$stateParams</code> is a service provided by <a href="https://github.com/angular-ui/ui-router" target="_blank">Angular's ui-router</a>. In this example, we're using it to access the <code>productId</code> parameter in the URL.)
          </p>

          <script src="https://gist.github.com/jcpinnovation/eb9cdd80eab15a053aa3.js"></script>
          
          <script src="https://gist.github.com/jcpinnovation/d45b5fa770340da9c29a.js"></script>

          <p>
            If you remember from the Factories section, <a href="https://docs.angularjs.org/api/ngResource/service/$resource" target="_blank">$resource</a> actions immediately return an empty reference, then populate the object/array with data when the response arrives. This means that we don't have to setup any callbacks in our controller. The above code is all we need to give our view access to its models. 
          </p>

          <p>
            Now, for our ProductController view, let's pretend we're using the markup below. This contrived example includes:
            <ol>
              <li>basic product information (name, description, image)</li>
              <li>a naive form for selecting product options, specifying quantity, and adding to bag</li>
              <li>reviews for the given product</li>
              <li>recommendations for the given product</li>
            </ol>

            Don't worry if the lack of modularity grosses you out; we'll get to that in the Directives section. <img class="emoji" alt=":)" src="img/wink.png">

          </p>

          <script src="https://gist.github.com/jcpinnovation/225faad4faed76493d6c.js"></script>

          <p>
            With its built-in directives, Angular can take care of our form's data-binding and even help out with validation, but we'll still need to handle the add-to-bag functionality ourselves. Notice the opening tag of our view's <code>form</code> element. It specifies a name <code>productForm</code> and submit action <code>ng-submit="addToBag(product)"</code>. Let's add a method to our scope, so we can respond to the <code>addToBag</code> call. The handler should verify that the form data is valid, then facilitate the hand-off of our product to the shopping bag. For the sake of simplicity, assume that <code>BagFactory.getInstance()</code> returns a singleton Bag model that exposes an <code>add</code> method for adding products.
          </p>

          <script src="https://gist.github.com/jcpinnovation/b30e395549b67227e6fb.js"></script>

          <p>
            Well, that wasn't so bad. And our ProductController is still pretty thin at eight lines of code. For an unsophisticated view, implementing an <code>addToBag</code> handler like this would be perfectly acceptable. But in reality, JCPenney's product detail page is going to involve much more functionality that's tied to UI events (think liking/saving products, writing reviews, forms for monogramming, accordion menus, etc). While we <i>could</i> just throw this all under one controller, there's a better way, which will help keep our code organized and reusable. In the next section, we'll talk about directives.
          </p>

        </section>

        <section>

          <h3>Directives</h3>
          
          <p>
            We've alluded to directives a few times up to this point. You might be wondering, "What exactly <i>are</i> these mysterious entities?" The <a href="https://docs.angularjs.org/guide/directive" target="_blank">official AngularJS documentation</a> is a bit technical, but hopefully begins to paint the picture:
          </p>

          <blockquote>
            <p>
              At a high level, directives are markers on a DOM element (such as an attribute, element name, comment or CSS class) that tell AngularJS's HTML compiler ($compile) to attach a specified behavior to that DOM element or even transform the DOM element and its children.
            </p>
          </blockquote>

          <p>
            One very important feature that the above definition fails to acknolwedge is that directives can manage their own scopes, as well as inherit those of their parent controllers. This means directives can function as "mini-controllers" of sorts, enabling us to better encapsulate and re-use components. The following excerpt from <a href="https://leanpub.com/web-component-development-with-angularjs/read" target="_blank">Web Component Architecture &amp; Development with AngularJS</a> elaborates on this idea:
          </p>

          <blockquote>
            <p>
              One of the most useful and powerful features of AngularJS is directives. AngularJS directives are a framework convention for creating custom extensions to HTML that can encapsulate both the view and behavior of a UI component such as a site search bar in a way that can limit external dependencies, as well as providing for very flexible configuration parameters that any application or container level code may wish to provide.
            </p>
            <p>
              The AngularJS team state that using AngularJS is a way to overcome the primary shortcoming of HTML, mainly that it was designed for static presentation not dynamic, data driven interaction and presentation - a key feature of today's web. Because HTML has not evolved to provide dynamic presentation, JavaScript frameworks have risen to fill the gap, the most popular being jQuery.
            </p>
            <p>
              jQuery gives us common boilerplate code for querying the DOM, binding and listening for user or browser events, and then imperatively updating or "re-painting" the DOM in response. This was great when web applications were simple. But web applications have grown very complex, and the boilerplate code can add up to thousands of lines of source mixed in with the actual application logic.
            </p>
            <p>
              AngularJS removes the boilerplate, thus allowing JavaScript developers to opportunity to concentrate solely on the business logic of the application, and in a way that hard dependencies to the DOM are removed.
            </p>
          </blockquote>

          <p>
            Now that we have a better idea of what directives are, let's try out a simple example. Consider JCPenney's product rating stars, which appear throughout the site in search results, product detail views, and recommendations. With directives, we can "componentize" that logic so that it can be shared by all the aforementioned views.
          </p>

          <script src="https://gist.github.com/jcpinnovation/8313c290d64544f48508.js"></script>

          <script src="https://gist.github.com/jcpinnovation/063c311fcc79ffa81717.js"></script>

          <script src="https://gist.github.com/jcpinnovation/076afd725a23f1b35020.js"></script>

          <p>
            So, what's happening here? The first Gist is just a template that works like any other Angular view. The view expects its scope to have an <code>isolatedProduct</code> (bear with the name for a moment). If the product has no reviews, the view renders nothing. Otherwise, it applies a "full" class to the appropriate number of stars, then displays the number of reviews in parentheses.
          </p>

          <p>
            The second Gist shows how we define our directive. Like many of its core modules, Angular expects our directive function to return an object. Let's look at some of its properties to see what's happening:

            <ul>
              <li>
                <b>restrict</b>: This property tells Angular how an element can communicate that it wants to use our directive. Possible values are:
                <ul>
                  <li>'A' for attribute: <code>&lt;div product-rating&gt;&lt;/div&gt;</code></li>
                  <li>'C' for class: <code>&lt;div class="product-rating"&gt;&lt;/div&gt;</code></li>
                  <li>'E' for element: <code>&lt;product-rating&gt;&lt;/product-rating&gt;</code></li>
                  <li>'M' for comment: <code>&lt;!-- product-rating --&gt;</code></li>
                  <li> we can also use any combination of the aforementioned characters, e.g. 'AE'</li>
                </ul>
                It should be noted that Angular automatically maps an elements' names/classes/attributes from "HTML/CSS-case" (i.e. all lowercase, separated by dashes) to camel-case.
              </li>
              <li>
                <b>scope</b>: This property tells Angular how to manage our directive's scope. Possible values are:
                <ul>
                  <li><code>false</code>: no scope</li>
                  <li><code>true</code>: a child of the parent controller's scope</li>
                  <li><code>{}</code>: an isolated scope</li>
                </ul>
                In the case of the latter (which we're opting for in this example), we'll need to specify key-value pairs to configure how our directive can bind to data provided by the element. The keys determine the property name on our isolated scope, while the corresponding values tell Angular what attributes to look for on the element. Typically, we would use "product" as the name for all of these variables, but right now we're opting for more verbose names to better illustrate how binding works. <a href="http://stackoverflow.com/questions/14914213/when-writing-a-directive-how-do-i-decide-if-a-need-no-new-scope-a-new-child-sc" target="_blank">This StackOverflow post</a> and <a href="https://gist.github.com/CMCDragonkai/6282750" taret="_blank">this Gist of example use cases</a> are great resources for learning more about the nuances of directive scopes.
              </li>
              <li>
                <b>replace</b>: This property tells Angular whether we want to:
                <ul>
                  <li>replace the original element with our template HTML (<code>true</code>)</li>
                  <li>or embed our template's HTML within the original element (<code>false</code>)</li>
                </ul>
              </li>
              <li>
                <b>templateUrl</b>: This property tells Angular where to find the template for our element (if applicable).
              </li>
            </ul>

          </p>

          <p>
            Last but not least is our third Gist, which shows how easily we can employ our product ratings directive anywhere in the site. Had we gone with a more natural naming scheme for our scope variables (i.e. <code>scope: { product: '=product' }</code>), the usage would be:
          </p>

          <script src="https://gist.github.com/jcpinnovation/922d5f05040e7299187a.js"></script>

          <p>
            And the rendered HTML might look something like this:
          </p>

          <script src="https://gist.github.com/jcpinnovation/679cc23746d02372380f.js"></script>

          <p>
            And there we have it - our first Angular directive! With six lines of Coffeescript, we've gained the ability to re-use our product rating stars anywhere in the site. And every instance will rely on the same HTML partial, so we can leverage caching to cut down on our bandwidth consumption (unlike less DRY approaches that nest product rating HTML into every view that requires it). 
          </p>

          <p>
            If you've used frameworks like Ruby on Rails in the past, our example probably feels familiar; it's very much like a view passing local variables to a partial. In Rails, the partial is free to use helpers or call instance methods on models, but unless you're injecting logic into places where it doesn't belong, that's the extent of a partial's functionality. Angular's directives tell a different story. By virtue of living on the client-side, Javascript is much more dynamic in nature. A front-end partial/directive can't spit out some markup, brush its hands off, and say, "I'm done!" It needs to hang on to its scope, and it may need to react to updated data or a user's input. Fortunately, the good people at Google have given us a nice tool to help out with this sort of thing.
          </p>

          <p>
            For our next example, we're going to create a product form... 
          </p>

          <p>
            More stuff here...
          </p>

          <p>
            The JCPenney site is full of opportunities to utilize directives; product results (like you would see after drilling down to a category or searching for "winter coats"), recommendations, reviews, loading indicators, and accordions are just a few candidates. And don't forget that directives can be nested within directives, so bite-sized components (like our product rating stars or a directive to display pricing information for a product) can be assembled into much more complex (but still self-contained) pieces of functionality.
          </p>

        </section>

      </section>

      <!-- ///////////////////////////////////////////////////////////////////////////// -->

      <section>

        <h2>App Structure</h2>

        <p>Coming soon!</p>

      </section>

      <!-- ///////////////////////////////////////////////////////////////////////////// -->

      <section>

        <h2>Task Runners</h2>
        <p>Coming soon!</p>

      </section>


      <!-- ///////////////////////////////////////////////////////////////////////////// -->

    </div>

  </body>
</html>