<!DOCTYPE html>
<html>
  
  <head>
    <meta name="viewport" content="width=device-width, user-scalable=no">
    <title>Angular Tips for JCPenney.com</title>
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/3.0.1/normalize.min.css" />
    <link href="https://fonts.googleapis.com/css?family=Lato" rel="stylesheet" type="text/css">
    <link rel="stylesheet" type="text/css" href="css/styleguide.css" />
  </head>
  
  <body>
    
    <div id="wrapper">

      <h1>Angular Tips for JCPenney.com</h1>

      <!-- ///////////////////////////////////////////////////////////////////////////// -->

      <section>

        <h2>Overview of Angular Components</h2>

        <section>

          <h3>Models</h3>

          <p>
            Unlike most of the components we'll cover, Angular has few opinions on how to manage your models. Whereas frameworks like <a href="http://backbonejs.org/#Model" target="_blank">Backbone</a> or <a href="http://backbonejs.org/#Model" target="_blank">Ember.js</a> have special objects to model data, Angular requires nothing more than a plain old javascript object. Considering the size and complexity of the JCPenney website, we would be missing out on a great opportunity to DRY our code if we didn't fatten up those objects with some extra functionality.
          </p>

          <p>
            Take a look at the example <a href="https://github.com/jcpenney/jcp-responsive-v2/blob/master/src/coffee/models/product.coffee" target="_blank">Product</a> model below, which inherits from a bare-bones <a href="https://github.com/jcpenney/jcp-responsive-v2/blob/master/src/coffee/models/base.coffee" target="_blank">ModelBase</a>.
          </p>

          <script src="https://gist.github.com/jcpinnovation/2cc6b5d786a30f80f12d.js"></script>

          <p>
            While its business logic is certainly oversimplified, hopefully the potential value of a more formally typed and augmented object (as opposed to a data-only object) is becoming apparent. Below is a second example, a very simple <a href="https://github.com/jcpenney/jcp-responsive-v2/blob/master/src/coffee/models/review.coffee" target="_blank">Review</a> model, which could be useful for parts of the site that call for an average rating.
          </p>

          <script src="https://gist.github.com/jcpinnovation/96e554b1c2cd70d32de7.js"></script>

          <p>
            It's worth noting that each of the above-mentioned model classes is the return value for its own Angular Service. This allows us to inject the model as a dependency like we would any other Angular module, and because <a href="https://docs.angularjs.org/guide/services" target="_blank">services are singletons</a>, we don't have to worry about the class being defined more than once. We can even build subclasses, as can be seen in both of the above examples (inheriting from <a href="https://github.com/jcpenney/jcp-responsive-v2/blob/master/src/coffee/models/base.coffee" target="_blank">ModelBase</a>) or in <a href="https://github.com/jcpenney/jcp-responsive-v2/blob/master/src/coffee/models/department.coffee" target="_blank">this Department model</a>, which is a subclass of <a href="https://github.com/jcpenney/jcp-responsive-v2/blob/master/src/coffee/models/category.coffee" target="_blank">Category</a>, which is a subclass of <a href="https://github.com/jcpenney/jcp-responsive-v2/blob/master/src/coffee/models/base.coffee" target="_blank">ModelBase</a>. Once the dependency has been injected, instantiating a new instance is just a matter of typing <code>new Product(data)</code>. But where does this <code>data</code> come from, and where should models get instantiated, you ask? We'll talk about that in the next section.
          </p>

        </section>

        <section>

          <h3>Factories</h3>
          
          <p>
            As a rule of thumb, API calls and model instantiation should always be handled by a (lowercase-s) service. When it comes to choosing exactly which type of service to employ, we have the following options at our disposal, in order of increasing complexity: Services, Factories, and Providers. In most cases, we won't require service configuration during the <code>module.config</code> phase, <a href="http://demisx.github.io/angularjs/2014/09/14/angular-what-goes-where.html" target="_blank">so let's set Providers aside</a>. Services <i>could</i> get the job done, but Factories are probably a better option; as <i><a href="http://www.amazon.com/dp/1782161821/?tag=stackoverfl08-20" target="_blank">Mastering Web Application Development with AngularJS</a></i> eloquently puts it:
          </p>

          <blockquote>
            <p>
              The factory method is the most common way of getting objects into AngularJS dependency injection system. It is very flexible and can contain sophisticated creation logic. Since factories are regular functions, we can also take advantage of a new lexical scope to simulate "private" variables. This is very useful as we can hide implementation details of a given service. 
            </p>
          </blockquote>

          <p>
            Factories sound like a good fit, don't they? Now that we've decided on our data-fetching-and-model-instantiation service of choice, let's talk about how to interact with our API. The obvious answer might be to use Angular's core <a href="https://docs.angularjs.org/api/ng/service/$http" target="_blank">$http</a> service, and that approach would be perfectly acceptable. However, considering the RESTful nature of JCPenney's API, we can take the abstraction up a level and really DRY out our code with Angular's <a href="https://docs.angularjs.org/api/ngResource/service/$resource" target="_blank">$resource</a> factory. Take a look at the very naive DepartmentFactory below. (In case you're wondering, <a href="https://gist.github.com/jcpinnovation/ec7a670995fb68dd298b" target="_blank">here is the Config service</a> we're injecting.)
          </p>

          <script src="https://gist.github.com/jcpinnovation/73312408ba3dc793c847.js"></script>

          <p>
            By taking advantage of <a href="https://docs.angularjs.org/api/ngResource/service/$resource" target="_blank">$resource</a>, we now have the ability to fetch data for all departments or a single department with the following code:
          </p>

          <script src="https://gist.github.com/jcpinnovation/3495e0cc2a794205e1fb.js"></script>

          <p>
            You might be thinking, "Well, that's nice, but what about creating, updating, and destroying resources? And what if we need more than the basic CRUD operations?" Hold that thought for a moment. First, let's talk about how we can cast our API responses as models, like the ones we discussed in the previous section.
          </p>

          <p>
            The key to transforming our API response data into more useful models is <a href="https://docs.angularjs.org/api/ng/service/$http" target="_blank">$http</a>'s <code>transformResponse</code> hook, which is conveniently exposed by <a href="https://docs.angularjs.org/api/ngResource/service/$resource" target="_blank">$resource</a>. With a relatively small amount of setup code, we can create a <a href="https://github.com/jcpenney/jcp-responsive-v2/blob/master/src/coffee/factories/base.coffee">FactoryBase</a> service, providing convenience methods to generate JSON-to-model transforms for our API responses. We'll also configure basic actions for creating, updating, and destroying our custom models on the server.
          </p>

          <script src="https://gist.github.com/jcpinnovation/407c02bceb6c18c027cf.js"></script>

          <p>
            Next, we'll have DepartmentFactory extend our newly created FactoryBase, then call <code>generateResourceForModel</code> to build its default actions:
          </p>

          <script src="https://gist.github.com/jcpinnovation/b55becd4fe2b5808b53f.js"></script>

          <p>
            Now DepartmentFactory's <code>GET</code> requests will return Department models (rather than vanilla javascript objects), and we can pass our custom models as arguments to create, update, and destroy remote resources. The JCPenney API doesn't currently support mutative actions for Departments, but for the sake of this example, let's pretend it does. The code below shows how we would execute all five CRUD operations with DepartmentFactory.
          </p>

          <script src="https://gist.github.com/jcpinnovation/e47865929d53089b6db0.js"></script>

          <p>
            Neat, huh? We've got the hardest part out of the way, so let's address the second part of your question, about accessing resource endpoints beyond the basic CRUD operations. Consider the <code>GET product/:id/reviews</code> endpoint, which returns reviews associated with a given product. After implementing the boilerplate factory code (to inherit from <a href="https://gist.github.com/jcpinnovation/407c02bceb6c18c027cf" target="_blank">FactoryBase</a> and override <code>transformResponse</code> for both <code>GET</code> methods), we only need to add five lines of Coffeescript to provide support for our product reviews endpoint.
          </p>

          <script src="https://gist.github.com/jcpinnovation/9c51438958c471dfe33d.js"></script>

          <p>
            Notice that we're passing the <a href="https://gist.github.com/jcpinnovation/96e554b1c2cd70d32de7" target="_blank">Review</a> model to <code>generateArrayTransformFunctionForModel</code>, as well as specifying the optional <code>arrayPath</code> argument. The latter tells our helper method to look to the <code>reviews</code> property for its data. If this doesn't make sense right away, take a look at <a href="http://api.jcpenney.com/v2/products/pp5002690485/reviews" target="_blank">a sample product review response</a>. The <code>isArray</code> option is required by <a href="https://docs.angularjs.org/api/ngResource/service/$resource" target="_blank">$resource</a> and simply tells the service we'll be returning data in the form of an array, not an object. The code below demonstrates how we actually go about calling our new action, which will return an array of Review models.
          </p>

          <script src="https://gist.github.com/jcpinnovation/1c95ed19a8370c59c79f.js"></script>

          <p>
            And lastly, before moving onto the next section, let's take a moment to acknowledge one of the <a href="https://docs.angularjs.org/api/ngResource/service/$resource" target="_blank">$resource</a> module's most beautiful features. From Angular's documentation: 
          </p>

          <blockquote>
            <p>
              It is important to realize that invoking a $resource object method immediately returns an empty reference (object or array depending on isArray). Once the data is returned from the server the existing reference is populated with the actual data. This is a useful trick since usually the resource is assigned to a model which is then rendered by the view. Having an empty object results in no rendering, once the data arrives from the server then the object is populated with the data and the view automatically re-renders itself showing the new data. This means that in most cases one never has to write a callback function for the action methods.
            </p>
          </blockquote>

          <p>
            Because our factory methods immediately return an empty object/array, then populate that object/array and automatically re-render any relevant views when the data arrives, oftentimes we'll have no need for a callback. As we'll see in the next section, this is very beneficial when it comes to keeping our controllers lean.
          </p>

        </section>

        <section>

          <h3>Controllers</h3>

          <p>
            To borrow from Todd Motto's <a href="http://toddmotto.com/rethinking-angular-js-controllers" target="_blank">"Rethinking AngularJS Controllers"</a>, the primary role of an AngularJS controller is to bring logic together; it should trigger model and view changes, but avoid getting involved in the details of their operations. The responsibility of updating models should be left to factories or the models themselves. Likewise, any changes to the UI should be addressed by directives or the views themselves.
          </p>

          <p>
            <b>
              If we're doing everything right, our controllers will contain very little code.
            </b>
          </p>

          <p>
            Let's quickly add support for querying product recommendations to our ProductFactory, then we'll look at how ProductController can give its view access to the Product, Recommendation, and Review models it needs. (In case you're wondering, <code>$stateParams</code> is a service provided by <a href="https://github.com/angular-ui/ui-router" target="_blank">Angular's ui-router</a>. In this example, we're using it to access the <code>productId</code> parameter in the URL.)
          </p>

          <script src="https://gist.github.com/jcpinnovation/eb9cdd80eab15a053aa3.js"></script>
          
          <script src="https://gist.github.com/jcpinnovation/d45b5fa770340da9c29a.js"></script>

          <p>
            If you remember from the Factories section, <a href="https://docs.angularjs.org/api/ngResource/service/$resource" target="_blank">$resource</a> actions immediately return an empty reference, then populate the object/array with data when the response arrives. This means that we don't have to setup any callbacks in our controller. The above code is all we need to give our view access to its models. 
          </p>

          <p>
            Now, for our ProductController view, let's pretend we're using the markup below. This contrived example includes:
            <ol>
              <li>basic product information (name, description, image)</li>
              <li>a naive form for selecting product options, specifying quantity, and adding to bag</li>
              <li>reviews for the given product</li>
              <li>recommendations for the given product</li>
            </ol>

            Don't worry if the lack of modularity grosses you out; we'll get to that in the Directives section. <img class="emoji" alt=":)" src="img/wink.png">

          </p>

          <script src="https://gist.github.com/jcpinnovation/225faad4faed76493d6c.js"></script>

          <p>
            With its built-in directives, Angular can take care of our form's data-binding and even help out with validation, but we'll still need to handle the add-to-bag functionality ourselves. Notice the opening tag of our view's <code>form</code> element. It specifies a name <code>productForm</code> and submit action <code>ng-submit="addToBag(product)"</code>. Let's add a method to our scope, so we can respond to the <code>addToBag</code> call. The handler should verify that the form data is valid, then facilitate the hand-off of our product to the shopping bag. For the sake of simplicity, assume that Bag is a singleton model that exposes an <code>add</code> method for adding products.
          </p>

          <script src="https://gist.github.com/jcpinnovation/b30e395549b67227e6fb.js"></script>

          <p>
            Well, that wasn't so bad. And our ProductController is still pretty thin at eight lines of code. For an unsophisticated view, implementing an <code>addToBag</code> handler like this would be perfectly acceptable. But in reality, JCPenney's product detail page is going to involve much more functionality that's tied to UI events (think liking/saving products, writing reviews, forms for monogramming, accordion menus, etc). While we <i>could</i> just throw this all under one controller, there's a better way, which will help keep our code organized and reusable. In the next section, we'll talk about directives.
          </p>

        </section>

        <section>

          <h3>Directives</h3>
          
          <p>
            We've alluded to directives a few times up to this point. You might be wondering, "What exactly <i>are</i> these mysterious entities?" The <a href="https://docs.angularjs.org/guide/directive" target="_blank">official AngularJS documentation</a> is a bit technical, but hopefully begins to paint the picture:
          </p>

          <blockquote>
            <p>
              At a high level, directives are markers on a DOM element (such as an attribute, element name, comment or CSS class) that tell AngularJS's HTML compiler ($compile) to attach a specified behavior to that DOM element or even transform the DOM element and its children.
            </p>
          </blockquote>

          <p>
            One very important feature that the above definition fails to acknolwedge is that directives can manage their own scopes, as well as inherit those of their parent controllers. This means directives can function as "mini-controllers" of sorts, enabling us to better encapsulate and re-use components. The following excerpt from <a href="https://leanpub.com/web-component-development-with-angularjs/read" target="_blank">Web Component Architecture &amp; Development with AngularJS</a> elaborates on this idea:
          </p>

          <blockquote>
            <p>
              One of the most useful and powerful features of AngularJS is directives. AngularJS directives are a framework convention for creating custom extensions to HTML that can encapsulate both the view and behavior of a UI component such as a site search bar in a way that can limit external dependencies, as well as providing for very flexible configuration parameters that any application or container level code may wish to provide.
            </p>
            <p>
              The AngularJS team state that using AngularJS is a way to overcome the primary shortcoming of HTML, mainly that it was designed for static presentation not dynamic, data driven interaction and presentation- a key feature of today's web. Because HTML has not evolved to provide dynamic presentation, JavaScript frameworks have risen to fill the gap, the most popular being jQuery.
            </p>
            <p>
              jQuery gives us common boilerplate code for querying the DOM, binding and listening for user or browser events, and then imperatively updating or "re-painting" the DOM in response. This was great when web applications were simple. But web applications have grown very complex, and the boilerplate code can add up to thousands of lines of source mixed in with the actual application logic.
            </p>
            <p>
              AngularJS removes the boilerplate, thus allowing JavaScript developers to opportunity to concentrate solely on the business logic of the application, and in a way that hard dependencies to the DOM are removed.
            </p>
          </blockquote>

        </section>

      </section>

      <!-- ///////////////////////////////////////////////////////////////////////////// -->

      <section>

        <h2>App Structure</h2>

        <p>Coming soon!</p>

      </section>

      <!-- ///////////////////////////////////////////////////////////////////////////// -->

      <section>

        <h2>Task Runners</h2>
        <p>Coming soon!</p>

      </section>


      <!-- ///////////////////////////////////////////////////////////////////////////// -->

    </div>

  </body>
</html>